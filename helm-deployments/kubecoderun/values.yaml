# KubeCodeRun Helm Chart Values

# API Deployment Configuration
replicaCount: 1

image:
  repository: ghcr.io/aron-muon/kubecoderun-api
  pullPolicy: IfNotPresent
  # tag defaults to Chart.AppVersion if not specified
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Service Account for the API pod
serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations: {}
podSecurityContext:
  fsGroup: 65532

securityContext:
  runAsNonRoot: true
  runAsUser: 65532
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false

service:
  type: ClusterIP
  port: 8000

ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: kubecoderun.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

resources:
  limits:
    cpu: 1000m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 256Mi

# Health check probes
# Startup probe handles slow-starting containers (pool warming takes ~60-90s)
startupProbe:
  enabled: true
  httpGet:
    path: /health
    port: http
  failureThreshold: 30
  periodSeconds: 5
  # 30 * 5 = 150 seconds max startup time

livenessProbe:
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 10
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 3

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80

nodeSelector: {}
tolerations: []
affinity: {}

# External Dependencies
redis:
  # Reference an existing Kubernetes Secret containing REDIS_URL
  # When set, the url/host/port/password/db fields below are ignored
  # Expected secret key: REDIS_URL (full connection string)
  existingSecret: ""

  # Deployment mode: standalone (default), cluster, or sentinel
  mode: "standalone"

  # External Redis URL (required unless existingSecret is set)
  url: "redis://redis:6379/0"
  # Or specify individual fields
  host: ""
  port: 6379
  password: ""
  db: 0
  # Advanced connection settings
  maxConnections: 20
  socketTimeout: 5
  socketConnectTimeout: 5

  # Optional key prefix prepended to every Redis key.
  # Useful when sharing a Redis instance across environments.
  keyPrefix: ""

  # Redis Cluster mode (mode: cluster)
  # Comma-separated host:port pairs for cluster startup nodes
  clusterNodes: ""

  # Redis Sentinel mode (mode: sentinel)
  # Comma-separated host:port pairs for sentinel instances
  sentinelNodes: ""
  sentinelMaster: "mymaster"
  sentinelPassword: ""

  # TLS/SSL settings (all modes)
  tls:
    enabled: false
    # Path to CA certificate inside the container
    caCertFile: ""
    # Client certificate and key for mutual TLS
    certFile: ""
    keyFile: ""
    # Skip server certificate verification (NOT recommended for production)
    insecure: false
    # Verify server hostname against certificate CN/SAN.
    # Off by default because managed Redis services and cluster mode
    # expose node IPs that typically don't match certificate names.
    checkHostname: false

minio:
  # Reference an existing Kubernetes Secret containing S3 credentials
  # When set, the accessKey/secretKey fields below are ignored
  # Expected secret keys: MINIO_ACCESS_KEY, MINIO_SECRET_KEY
  existingSecret: ""
  endpoint: "minio:9000"
  accessKey: ""
  secretKey: ""
  secure: false
  bucket: "kubecoderun-files"
  # Use IAM role for authentication (IRSA on EKS)
  # When true, accessKey and secretKey are not required
  useIAM: false
  # AWS region (required when useIAM is true)
  region: ""

# API Configuration
api:
  # Reference an existing Kubernetes Secret containing API keys
  # When set, the apiKey/masterApiKey fields below are ignored
  # Expected secret keys: API_KEY, and optionally MASTER_API_KEY
  existingSecret: ""
  apiKey: "" # Will be auto-generated if empty
  masterApiKey: "" # For admin operations
  debug: false
  logLevel: "INFO"
  logFormat: "json"

  # Logging
  enableAccessLogs: true
  enableSecurityLogs: true
  enableDocs: true

  # CORS (for development/specific use cases)
  cors:
    enabled: false
    origins: []

  # Health checks
  healthCheck:
    interval: 30
    timeout: 5

# Execution Configuration
execution:
  # Namespace for execution pods (defaults to Release.Namespace if empty)
  namespace: ""

  # Cleanup configuration for pool pods on helm uninstall
  cleanup:
    enabled: true

  # Image registry configuration
  # Images are named: {imageRegistry}-{language}:{imageTag}
  # e.g., ghcr.io/aron-muon/kubecoderun-python:1.0.0
  imageRegistry: "ghcr.io/aron-muon/kubecoderun"
  # imageTag defaults to Chart.AppVersion if not specified
  imageTag: ""
  # Image pull policy for execution pods (IfNotPresent, Always, Never)
  imagePullPolicy: "IfNotPresent"

  # Image pull secrets for private registries (applies to execution pods)
  # Example:
  # imagePullSecrets:
  #   - name: secret-for-registry
  #   - name: another-secret
  imagePullSecrets: []

  # Service account for execution pods (with pod/job create permissions)
  serviceAccount:
    create: true
    name: "kubecoderun-executor"
    annotations: {}

  # Execution mode: "agent" (default) or "nsenter" (legacy)
  # - agent: Executor agent runs inside main container. No nsenter, no capabilities,
  #   no privilege escalation. Compatible with GKE Sandbox (gVisor). Requires the
  #   sidecar-agent image (default build target).
  # - nsenter: Sidecar uses nsenter to enter the main container's namespace. Requires
  #   the sidecar-nsenter image, shareProcessNamespace, SYS_PTRACE/SYS_ADMIN/SYS_CHROOT
  #   capabilities, and allowPrivilegeEscalation: true.
  executionMode: "agent"

  # Port for the executor HTTP server inside the main container
  executorPort: 9090

  # Sidecar container configuration
  # In nsenter mode: user code runs in sidecar's cgroup via nsenter
  # In agent mode: sidecar only proxies requests, user code runs in main container's cgroup
  sidecar:
    repository: ghcr.io/aron-muon/kubecoderun-sidecar-agent
    # tag defaults to Chart.AppVersion if not specified
    tag: ""
    port: 8080
    resources:
      limits:
        cpu: "500m"
        memory: "512Mi"
      requests:
        cpu: "100m"
        memory: "256Mi"

  # Pod lifecycle configuration
  podTtlMinutes: 5
  podCleanupIntervalMinutes: 5

  # Pool behavior configuration
  pool:
    warmupOnStartup: true
    parallelBatch: 5
    replenishInterval: 2
    exhaustionTrigger: true

  # Per-language pool configuration
  # poolSize > 0: warm pods maintained
  # poolSize = 0: use Jobs (cold start)
  # Images default to {imageRegistry}-{language}:{imageTag or appVersion}
  # Set image: to override with a custom image for a specific language
  # Set resources: to override CPU/memory limits for specific languages
  # (falls back to sidecar.resources if not specified)
  languages:
    python:
      poolSize: 5
      # resources: (uses sidecar.resources defaults)
    javascript:
      poolSize: 2
    typescript:
      poolSize: 0
    go:
      poolSize: 0
      # Go compilation is CPU-intensive; consider increasing resources:
      # resources:
      #   limits:
      #     cpu: "2"
      #     memory: "1Gi"
      #   requests:
      #     cpu: "500m"
      #     memory: "512Mi"
    java:
      poolSize: 0
    rust:
      poolSize: 0
    c:
      # Uses c-cpp image by default
      imageSuffix: "c-cpp"
      poolSize: 0
    cpp:
      # Uses c-cpp image by default
      imageSuffix: "c-cpp"
      poolSize: 0
    php:
      poolSize: 0
    r:
      poolSize: 0
    fortran:
      poolSize: 0
    d:
      poolSize: 0

  # Job settings (for languages with poolSize=0)
  jobs:
    ttlSecondsAfterFinished: 60
    activeDeadlineSeconds: 300

  # Pod security context
  securityContext:
    runAsNonRoot: true
    runAsUser: 65532
    runAsGroup: 65532
    fsGroup: 65532
    readOnlyRootFilesystem: false
    # Seccomp profile for execution pods - blocks dangerous syscalls
    # Options: RuntimeDefault (recommended), Unconfined
    seccompProfile:
      type: RuntimeDefault

  # Resource limits for execution pods
  resources:
    limits:
      cpu: "1"
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 128Mi

  # Maximum execution time in seconds
  maxExecutionTime: 30

  # Network isolation
  networkPolicy:
    enabled: true
    denyEgress: true

  # GKE Sandbox (gVisor) Configuration
  # Provides additional kernel isolation for untrusted workloads using gVisor
  # See: https://docs.cloud.google.com/kubernetes-engine/docs/concepts/sandbox-pods
  gkeSandbox:
    # Enable GKE Sandbox for execution pods.
    # WARNING: When enabled, pods require nodes with the gVisor runtime class.
    # Pods will stay Pending on clusters without sandbox-enabled node pools.
    enabled: false

    # Runtime class name (default: gvisor for GKE)
    runtimeClassName: "gvisor"

    # Node selector for sandbox-enabled nodes
    # GKE automatically adds sandbox.gke.io/runtime=gvisor to sandbox nodes
    # Add additional selectors here if needed (e.g., for specific node pools)
    nodeSelector: {}
    # Example:
    #   sandbox.gke.io/runtime: gvisor
    #   cloud.google.com/gke-nodepool: sandbox-pool

    # Custom tolerations for node pool taints
    # GKE automatically adds toleration for sandbox.gke.io/runtime=gvisor
    # Use this for additional custom taints (e.g., dedicated sandbox node pools)
    customTolerations: []
    # Example:
    # - key: pool
    #   operator: Equal
    #   value: sandbox
    #   effect: NoSchedule
    # - key: sandbox.gke.io/runtime
    #   operator: Equal
    #   value: gvisor
    #   effect: NoSchedule

# Resource Limits Configuration
resourceLimits:
  # Execution limits
  maxMemoryMb: 512
  maxCpus: 4.0
  maxPids: 512
  maxOpenFiles: 1024

  # File limits
  maxFileSizeMb: 10
  maxTotalFileSizeMb: 50
  maxFilesPerSession: 50
  maxOutputFiles: 10

  # Session limits
  maxConcurrentExecutions: 10
  maxSessionsPerEntity: 100

# Session Lifecycle Configuration
sessions:
  ttlHours: 24
  cleanupIntervalMinutes: 10
  enableOrphanMinioCleanup: false

# State Persistence Configuration
state:
  enabled: true
  ttlSeconds: 7200
  maxSizeMb: 50
  captureOnError: false

  # Archival settings (Redis -> MinIO)
  archive:
    enabled: true
    afterSeconds: 3600
    ttlDays: 7
    checkIntervalSeconds: 300

# Metrics Configuration
metrics:
  detailed:
    enabled: true
    bufferSize: 10000
  archive:
    enabled: true
    retentionDays: 90
  sqlite:
    enabled: true
    dbPath: "data/metrics.db"
    executionRetentionDays: 90
    dailyRetentionDays: 365
    aggregationIntervalMinutes: 60

# Security Configuration
security:
  rateLimitEnabled: true
  networkIsolation: true
  filesystemIsolation: true

  # Pod hardening
  maskHostInfo: true
  genericHostname: "sandbox"

  # File restrictions (optional - uses defaults if empty)
  # allowedFileExtensions: []
  # blockedFilePatterns: []

# Network Configuration
network:
  # WAN access allows pods to reach the internet but blocks internal networks
  wan:
    enabled: false
    networkName: "kubecoderun-wan"
    dnsServers:
      - "8.8.8.8"
      - "1.1.1.1"
      - "8.8.4.4"

# RBAC for execution pods
rbac:
  create: true

# AWS Secrets Store CSI Driver Configuration
# When enabled, secrets are fetched from AWS Secrets Manager instead of Kubernetes secrets
secretsStore:
  enabled: false
  provider: "aws" # Currently only AWS is supported

  # The ARN of the secret in AWS Secrets Manager containing the environment variables
  # This secret should contain: REDIS_URL, MINIO_ENDPOINT, MINIO_BUCKET, AWS_REGION, etc.
  secretArn: ""

  # Objects to fetch from AWS Secrets Manager
  # Each object maps a secret ARN to environment variables
  objects: []
  # Example:
  # - secretArn: "arn:aws:secretsmanager:us-west-2:123456789:secret:my-secret"
  #   objectAlias: "kubecoderun-env"
  #   jmesPath:
  #     - path: "REDIS_URL"
  #       objectAlias: "REDIS_URL"
  #     - path: "MINIO_BUCKET"
  #       objectAlias: "MINIO_BUCKET"

  # Secret objects to sync as Kubernetes secrets (for envFrom)
  # These map the jmesPath aliases to Kubernetes secret keys
  secretObjects: []
  # Example:
  # - objectName: "REDIS_URL"
  #   key: "REDIS_URL"
  # - objectName: "MINIO_BUCKET"
  #   key: "MINIO_BUCKET"
