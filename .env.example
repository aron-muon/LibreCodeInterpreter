# Code Interpreter API Configuration

# API Configuration
API_HOST=0.0.0.0
API_PORT=8000
API_DEBUG=false
API_RELOAD=false

# SSL/HTTPS Configuration
ENABLE_HTTPS=false
HTTPS_PORT=443
SSL_REDIRECT=false

# Docker: Path to directory containing cert.pem and key.pem on the host
# The directory is mounted to /app/ssl/ inside the container automatically.
# Default is ./ssl (relative to docker-compose.yml)
# SSL_CERTS_PATH=/path/to/your/ssl/certs

# Non-Docker only: Absolute paths to certificate files (not needed for Docker)
# SSL_CERT_FILE=/path/to/cert.pem
# SSL_KEY_FILE=/path/to/key.pem
# SSL_CA_CERTS=/path/to/ca.pem

# Authentication Configuration
API_KEY=your-secure-api-key-here-change-this-in-production
# API_KEYS=key1,key2,key3  # Additional API keys (comma-separated)
API_KEY_HEADER=x-api-key
API_KEY_CACHE_TTL=300

# API Key Management Configuration
# MASTER_API_KEY=your-secure-master-key  # Required for CLI key management
RATE_LIMIT_ENABLED=true

# Redis Configuration
# Deployment mode: standalone (default), cluster, or sentinel
REDIS_MODE=standalone
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0
# Alternative: Use Redis URL instead of individual settings
# REDIS_URL=redis://localhost:6379/0
REDIS_MAX_CONNECTIONS=20
REDIS_SOCKET_TIMEOUT=5
REDIS_SOCKET_CONNECT_TIMEOUT=5

# Optional key prefix — useful when sharing a Redis instance across environments
# All keys will be stored as <prefix><key>  (e.g. "prod:sessions:abc")
REDIS_KEY_PREFIX=

# Redis Cluster Mode (REDIS_MODE=cluster)
# Comma-separated list of host:port pairs for cluster startup nodes
# REDIS_CLUSTER_NODES=node1:6379,node2:6379,node3:6379

# Redis Sentinel Mode (REDIS_MODE=sentinel)
# Comma-separated list of host:port pairs for Sentinel instances
# REDIS_SENTINEL_NODES=sentinel1:26379,sentinel2:26379,sentinel3:26379
# REDIS_SENTINEL_MASTER=mymaster
# REDIS_SENTINEL_PASSWORD=

# Redis TLS/SSL Configuration
# Required for most managed Redis services (GCP Memorystore, AWS ElastiCache, Azure Cache)
REDIS_TLS_ENABLED=false
# REDIS_TLS_CA_CERT_FILE=/path/to/ca.crt
# REDIS_TLS_CERT_FILE=/path/to/client.crt
# REDIS_TLS_KEY_FILE=/path/to/client.key
# REDIS_TLS_INSECURE=false
# Hostname verification is off by default because managed Redis services
# and Redis Cluster mode expose node IPs that don't match cert CN/SAN.
# The CA certificate chain is still fully verified. Enable hostname
# checking when your Redis server hostnames match certificate CN/SAN.
# REDIS_TLS_CHECK_HOSTNAME=false

# MinIO/S3 Configuration
MINIO_ENDPOINT=localhost:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_SECURE=false
MINIO_BUCKET=kubecoderun-files
MINIO_REGION=us-east-1

# Docker Configuration
DOCKER_IMAGE_REGISTRY=kubecoderun
# DOCKER_BASE_URL=unix://var/run/docker.sock
DOCKER_TIMEOUT=60
DOCKER_NETWORK_MODE=none
DOCKER_READ_ONLY=true

# Resource Limits - Execution
MAX_EXECUTION_TIME=120
MAX_MEMORY_MB=512
MAX_CPUS=1
MAX_CPU_QUOTA=50000 #Deprecated
MAX_PIDS=512
MAX_OPEN_FILES=1024

# Resource Limits - Files
MAX_FILE_SIZE_MB=10
MAX_TOTAL_FILE_SIZE_MB=50
MAX_FILES_PER_SESSION=50
MAX_OUTPUT_FILES=10
MAX_FILENAME_LENGTH=255

# Resource Limits - Sessions
MAX_CONCURRENT_EXECUTIONS=10
MAX_SESSIONS_PER_ENTITY=100

# Session Configuration
# TTL applies only to MinIO-stored session data (files/metadata). Containers are ephemeral per execution.
SESSION_TTL_HOURS=24
SESSION_CLEANUP_INTERVAL_MINUTES=60
SESSION_ID_LENGTH=32

# MinIO Orphan Cleanup (optional)
# Enable periodic pruning of MinIO objects older than TTL with missing Redis sessions
ENABLE_ORPHAN_MINIO_CLEANUP=true

# Pod Pool Configuration
POD_POOL_ENABLED=true
POD_POOL_WARMUP_ON_STARTUP=true

# Per-language pool sizes (0 = on-demand only, no pre-warming)
# Only set the languages you want to pre-warm
POD_POOL_PY=5     # Python
POD_POOL_JS=2     # JavaScript
# POD_POOL_TS=0   # TypeScript (default: 0)
# POD_POOL_GO=0   # Go (default: 0)
# POD_POOL_JAVA=0 # Java (default: 0)
# POD_POOL_C=0    # C (default: 0)
# POD_POOL_CPP=0  # C++ (default: 0)
# POD_POOL_PHP=0  # PHP (default: 0)
# POD_POOL_RS=0   # Rust (default: 0)
# POD_POOL_R=0    # R (default: 0)
# POD_POOL_F90=0  # Fortran (default: 0)
# POD_POOL_D=0    # D (default: 0)

# Pool optimization settings
POD_POOL_PARALLEL_BATCH=5
POD_POOL_REPLENISH_INTERVAL=2
POD_POOL_EXHAUSTION_TRIGGER=true

# State Persistence Configuration (Python)
# Enables Python variable/function persistence across executions within same session
STATE_PERSISTENCE_ENABLED=true
# Redis hot storage TTL (default: 2 hours)
STATE_TTL_SECONDS=7200
# Maximum serialized state size
STATE_MAX_SIZE_MB=50
# Capture state even on execution failure
STATE_CAPTURE_ON_ERROR=false

# State Archival Configuration (Python)
# Archives inactive states from Redis to MinIO for long-term storage
STATE_ARCHIVE_ENABLED=true
# Archive to MinIO after this inactivity period (default: 1 hour)
STATE_ARCHIVE_AFTER_SECONDS=3600
# Keep archived states in MinIO for this many days
STATE_ARCHIVE_TTL_DAYS=7
# How often to check for states to archive
STATE_ARCHIVE_CHECK_INTERVAL_SECONDS=300

# Detailed Metrics Configuration
# Track per-API-key, per-language execution metrics
DETAILED_METRICS_ENABLED=true
# Maximum metrics to buffer in memory
METRICS_BUFFER_SIZE=10000
# Archive metrics to MinIO for long-term analysis
METRICS_ARCHIVE_ENABLED=true
# Keep archived metrics for this many days
METRICS_ARCHIVE_RETENTION_DAYS=90

# Security Configuration
ENABLE_NETWORK_ISOLATION=true
ENABLE_FILESYSTEM_ISOLATION=true

# Kubernetes Execution Configuration
# Execution mode: 'agent' (default, recommended) or 'nsenter' (legacy)
#   agent:   Executor-agent binary runs inside the main container.
#            No nsenter, no capabilities, no privilege escalation.
#            Compatible with GKE Sandbox (gVisor) and restricted Pod Security Standards.
#   nsenter: Sidecar uses nsenter to enter the main container's mount namespace.
#            Requires shareProcessNamespace, SYS_PTRACE/SYS_ADMIN/SYS_CHROOT caps,
#            and allowPrivilegeEscalation: true. NOT compatible with GKE Sandbox.
K8S_EXECUTION_MODE=agent
# K8S_EXECUTOR_PORT=9090  # Port for the executor-agent HTTP server (agent mode only)

# Sidecar image — must match the execution mode:
#   agent mode:   aronmuon/kubecoderun-sidecar-agent:latest   (default)
#   nsenter mode: aronmuon/kubecoderun-sidecar-nsenter:latest
# K8S_SIDECAR_IMAGE=aronmuon/kubecoderun-sidecar-agent:latest

# Image pull policy for execution pods (Always, IfNotPresent, Never)
# K8S_IMAGE_PULL_POLICY=Always

# Image pull secrets for private container registries (comma-separated secret names)
# These Kubernetes secrets must already exist in the execution namespace.
# Leave empty or unset if not using private registries.
# K8S_IMAGE_PULL_SECRETS=my-registry-secret,another-secret

# GKE Sandbox (gVisor) Configuration
# Requires K8S_EXECUTION_MODE=agent (nsenter is incompatible with gVisor)
# GKE_SANDBOX_ENABLED=false
# GKE_SANDBOX_RUNTIME_CLASS=gvisor
# GKE_SANDBOX_NODE_SELECTOR={}
# GKE_SANDBOX_CUSTOM_TOLERATIONS=[]

# WAN Network Access Configuration
# When enabled, execution containers can access the public internet
# but are blocked from accessing host, other containers, and private networks
# IMPORTANT: Requires NET_ADMIN capability for iptables management
ENABLE_WAN_ACCESS=false
WAN_NETWORK_NAME=kubecoderun-wan
# WAN_DNS_SERVERS=8.8.8.8,1.1.1.1,8.8.4.4

# Logging Configuration
LOG_LEVEL=INFO
LOG_FORMAT=json
# LOG_FILE=/var/log/kubecoderun-api.log
LOG_MAX_SIZE_MB=100
LOG_BACKUP_COUNT=5
ENABLE_ACCESS_LOGS=true
ENABLE_SECURITY_LOGS=true

# Health Check Configuration
HEALTH_CHECK_INTERVAL=30
HEALTH_CHECK_TIMEOUT=5

# Development Configuration
ENABLE_CORS=false
# CORS_ORIGINS=http://localhost:3000,http://localhost:8080
ENABLE_DOCS=false
